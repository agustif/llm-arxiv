import pytest
from llm_arxiv import extract_arxiv_id, arxiv_loader, parse_ranges_to_set, parse_image_selection_spec, _process_arxiv_paper, ImageSelectionCriteria
from unittest.mock import patch, MagicMock, call
import llm
import arxiv
import base64
from click.testing import CliRunner
from llm.cli import cli as llm_cli # To test llm subcommands
import sys
import io
import datetime


# --- Helper function for comparing markdown output ---
def normalize_markdown_for_compare(text: str) -> str:
    lines = text.replace('\r\n', '\n').split('\n')
    # Strip whitespace from each line AND filter out lines that become empty after stripping
    # This makes it robust to varying numbers of blank lines.
    processed_lines = [line.strip() for line in lines if line.strip()]
    return '\n'.join(processed_lines)


@pytest.mark.parametrize(
    "argument, expected_id",
    [
        # Standard IDs
        ("2310.06825", "2310.06825"),
        ("2310.06825v1", "2310.06825v1"),
        ("1234.56789", "1234.56789"),
        # URLs
        ("https://arxiv.org/abs/2310.06825", "2310.06825"),
        ("http://arxiv.org/abs/2310.06825v2", "2310.06825v2"),
        ("https://arxiv.org/pdf/1234.56789.pdf", "1234.56789"),
        ("http://arxiv.org/pdf/1234.56789v3.pdf", "1234.56789v3"),
        # Older IDs
        ("hep-th/0101001", "hep-th/0101001"),
        ("math.GT/0309136", "math.GT/0309136"),
        ("cs.AI/0101001", "cs.AI/0101001"),
        # Invalid cases
        ("not an id", None),
        ("https://example.com/abs/2310.06825", None),
        ("arxiv.org/abs/2310.06825", None), # Missing scheme
        ("123.456", None), # Incorrect format
        ("cs.AI/123456", None), # Incorrect old format (needs 7 digits)
    ]
)
def test_extract_arxiv_id(argument, expected_id):
    assert extract_arxiv_id(argument) == expected_id


@patch("llm_arxiv.fitz.open")
@patch("llm_arxiv.arxiv.Search")
@patch("llm_arxiv.Image.open")
def test_arxiv_loader_success(mock_llm_image_open, mock_search_class, mock_fitz_open):
    # --- Mock arXiv Search and Result ---
    mock_search_instance = MagicMock()
    mock_paper = MagicMock(spec=arxiv.Result)
    mock_paper.entry_id = "http://arxiv.org/abs/1234.5678v1"
    mock_paper.download_pdf.return_value = "/tmp/fake_paper.pdf"
    mock_search_instance.results.return_value = iter([mock_paper])
    mock_search_class.return_value = mock_search_instance

    # --- Mock PyMuPDF (fitz) ---
    mock_doc = MagicMock()
    mock_page1 = MagicMock()
    mock_page1.get_text.return_value = "Page 1 text <img src='p1_img1_placeholder_in_html'>" # HTML with img
    mock_page1.get_images.return_value = [(10,)] # (xref,) - one image on page 1
    mock_page2 = MagicMock()
    mock_page2.get_text.return_value = "Page 2 text" # No images on page 2
    mock_page2.get_images.return_value = []
    mock_doc.__iter__.return_value = iter([mock_page1, mock_page2])
    # Mock the extract_image call for the image on page 1
    mock_doc.extract_image.return_value = {"image": b"fake_image_bytes_for_10", "ext": "png"}
    
    # Mock Pillow for image processing
    mock_pil_image = MagicMock()
    mock_pil_image.width = 100
    mock_pil_image.height = 100
    mock_pil_image.mode = 'RGB' # ensure mode is set
    # Define a side effect for save to simulate writing to BytesIO
    def mock_save(buffer, format, optimize=None, quality=None, **kwargs):
        buffer.write(b"processed_fake_image_bytes")
        return None
    mock_pil_image.save = mock_save
    mock_llm_image_open.return_value = mock_pil_image

    mock_doc.__enter__.return_value = mock_doc
    
    # Ensure __exit__ calls close() and returns None
    def mock_exit_calls_close(*args):
        mock_doc.close() # Call the close method on mock_doc
        return None
    mock_doc.__exit__.side_effect = mock_exit_calls_close

    # mock_fitz_open should return mock_doc
    mock_fitz_open.return_value = mock_doc

    # --- Call the loader with image request ---
    fragments = arxiv_loader("1234.5678?i=all") # Request all images

    # --- Assertions ---
    assert isinstance(fragments, list)
    assert len(fragments) == 2 # Text fragment + 1 image attachment (processed)
    
    # Check the first fragment (text)
    text_fragment = fragments[0]
    assert isinstance(text_fragment, llm.Fragment)
    assert text_fragment.source == "http://arxiv.org/abs/1234.5678v1" # Source URL from paper
        
    # Expected text: HTML from pages, with <img> replaced by [IMAGE: conceptual_url], then markdownified
    # Mocked HTML for page 1: "Page 1 text <img src='p1_img1_placeholder_in_html'>"
    # Placeholder generated by _process_arxiv_paper: [IMAGE: http://arxiv.org/abs/1234.5678v1#page_1_img_1]
    # Markdownify will convert the rest.
    expected_normalized_parts = [
        "Page 1 text",
        "[IMAGE: http://arxiv.org/abs/1234.5678v1#page\\_1\\_img\\_1]", # Changed from \\\\_
        "Page 2 text"
    ]
    expected_normalized_str = "\\n".join(expected_normalized_parts)
    actual_normalized_str = normalize_markdown_for_compare(str(text_fragment))
    # print(f"ACTUAL NORM: {repr(actual_normalized_str)}")
    # print(f"EXPECT NORM: {repr(expected_normalized_str)}")
    assert actual_normalized_str == expected_normalized_str

    # Check the attachment (the processed image)
    attachment = fragments[1]
    assert isinstance(attachment, llm.Attachment)
    assert attachment.content == b"processed_fake_image_bytes" # Processed by mocked Pillow
    assert attachment.type == "image/png" # Default processing output is PNG if not JPEG

    # Check mocks were called correctly
    mock_search_class.assert_called_once_with(id_list=["1234.5678"], max_results=1)
    mock_search_instance.results.assert_called_once()
    mock_paper.download_pdf.assert_called_once()
    mock_fitz_open.assert_called_once_with("/tmp/fake_paper.pdf")
        
    # _process_arxiv_paper calls get_text and get_images
    assert mock_page1.get_text.call_count == 1
    assert mock_page2.get_text.call_count == 1
    assert mock_page1.get_images.call_count == 1 # Called to find images
    assert mock_page2.get_images.call_count == 1 # Called even if no images

    # Ensure doc.extract_image was called for the image on page 1
    mock_doc.extract_image.assert_called_once_with(10)
    # Ensure Pillow was involved
    mock_llm_image_open.assert_called_once()
    actual_call_args = mock_llm_image_open.call_args[0]
    assert isinstance(actual_call_args[0], io.BytesIO)
    assert actual_call_args[0].getvalue() == b"fake_image_bytes_for_10"
    
    # Ensure doc.close() was called
    mock_doc.close.assert_called_once()


@pytest.mark.parametrize(
    "argument, expected_error_msg_part",
    [
        ("invalid-id", "Invalid arXiv identifier or URL in fragment argument: invalid-id"),
        ("http://example.com/1234.5678", "Invalid arXiv identifier or URL in fragment argument: http://example.com/1234.5678"),
    ]
)
def test_arxiv_loader_invalid_id(argument, expected_error_msg_part):
    with pytest.raises(ValueError) as excinfo:
        arxiv_loader(argument) # Reverted to use argument
    assert expected_error_msg_part in str(excinfo.value) # Original assertion should now pass


@patch("llm_arxiv.arxiv.Search")
def test_arxiv_loader_no_results(mock_search_class):
    # Configure Search to return an empty iterator
    mock_search_instance = MagicMock()
    mock_search_instance.results.return_value = iter([])
    mock_search_class.return_value = mock_search_instance

    with pytest.raises(ValueError) as excinfo:
        arxiv_loader("1234.5678")
    assert "No paper found for arXiv ID: 1234.5678" in str(excinfo.value)
    mock_search_class.assert_called_once_with(id_list=["1234.5678"], max_results=1)


@patch("llm_arxiv.arxiv.Search")
def test_arxiv_loader_arxiv_api_error(mock_search_class):
    # Configure Search results to raise an exception
    mock_search_instance = MagicMock()
    # Use arxiv.HTTPError for the side_effect, providing only required args
    mock_search_instance.results.side_effect = arxiv.HTTPError(
        url="http://fake.export.arxiv.org",
        status=500,
        retry=False
    )
    mock_search_class.return_value = mock_search_instance

    with pytest.raises(ValueError) as excinfo:
        arxiv_loader("1234.5678")
    # Check that the error message contains the actual HTTPError string representation
    expected_msg = "Failed to fetch paper details from arXiv. Check network or ID/URL. Error: Page request resulted in HTTP 500 (http://fake.export.arxiv.org)"
    assert expected_msg in str(excinfo.value)
    mock_search_class.assert_called_once_with(id_list=["1234.5678"], max_results=1)


@patch("llm_arxiv.arxiv.Search")
def test_arxiv_loader_pdf_download_error(mock_search_class):
    # Configure download_pdf to raise an exception
    mock_search_instance = MagicMock()
    mock_paper = MagicMock(spec=arxiv.Result)
    mock_paper.entry_id = "http://arxiv.org/abs/1234.5678v1"
    mock_paper.download_pdf.side_effect = Exception("Download failed")
    mock_search_instance.results.return_value = iter([mock_paper])
    mock_search_class.return_value = mock_search_instance

    with pytest.raises(ValueError) as excinfo:
        arxiv_loader("1234.5678")
    # The error message wraps the original exception
    assert "Error processing arXiv paper 1234.5678 for fragment: Download failed" in str(excinfo.value)
    mock_search_class.assert_called_once_with(id_list=["1234.5678"], max_results=1)
    mock_paper.download_pdf.assert_called_once()


@patch("llm_arxiv.fitz.open")
@patch("llm_arxiv.arxiv.Search")
def test_arxiv_loader_pdf_extract_error(mock_search_class, mock_fitz_open):
    # Configure search and download to succeed
    mock_search_instance = MagicMock()
    mock_paper = MagicMock(spec=arxiv.Result)
    mock_paper.entry_id = "http://arxiv.org/abs/1234.5678v1"
    mock_paper.download_pdf.return_value = "/tmp/fake_paper.pdf"
    mock_search_instance.results.return_value = iter([mock_paper])
    mock_search_class.return_value = mock_search_instance

    # Configure fitz.open to raise an exception
    mock_fitz_open.side_effect = Exception("Fitz error")

    with pytest.raises(ValueError) as excinfo:
        arxiv_loader("1234.5678")

    # Check the wrapped error message
    expected_msg = "Failed to extract content from PDF /tmp/fake_paper.pdf: Fitz error"
    assert expected_msg in str(excinfo.value)
    mock_search_class.assert_called_once_with(id_list=["1234.5678"], max_results=1)
    mock_paper.download_pdf.assert_called_once()
    mock_fitz_open.assert_called_once_with("/tmp/fake_paper.pdf")


# --- Tests for parse_ranges_to_set --- pytest.py tests/test_arxiv.py
@pytest.mark.parametrize(
    "range_str, expected_set",
    [
        ("1", {1}),
        ("1,2,3", {1, 2, 3}),
        ("1-3", {1, 2, 3}),
        ("1,3-5,7", {1, 3, 4, 5, 7}),
        ("5-3", None), # Invalid range order
        ("1-3,5-4", None), # One invalid range
        ("abc", None), # Non-numeric
        ("1,abc,3", None), # Mixed non-numeric
        ("1-abc", None), # Non-numeric in range
        ("", set()),
        ("  1, 2  , 3-4 ", {1,2,3,4}),
        ("0", None), # Zero not allowed
        ("1-0", None), # Zero in range not allowed
        ("-2", None) # Negative not allowed
    ]
)
def test_parse_ranges_to_set(range_str, expected_set):
    if expected_set is None:
        with pytest.raises(ValueError):
            parse_ranges_to_set(range_str)
    else:
        assert parse_ranges_to_set(range_str) == expected_set


# --- Tests for parse_image_selection_spec --- pytest.py tests/test_arxiv.py
@pytest.mark.parametrize(
    "spec_string, expected_criteria",
    [
        (None, None),
        ("all", {"mode": "all"}),
        ("ALL", {"mode": "all"}),
        ("true", {"mode": "all"}),
        ("yes", {"mode": "all"}),
        ("1", {"mode": "all"}),
        ("", {"mode": "all"}), # Empty string implies all (e.g. from -i with no arg if const was used)
        ("none", None),
        ("NONE", None),
        ("false", None),
        ("no", None),
        ("0", None),
        ("G:1", {"mode": "global", "indices": {1}}),
        ("g:1,2,3", {"mode": "global", "indices": {1, 2, 3}}),
        ("G:1-3,5", {"mode": "global", "indices": {1, 2, 3, 5}}),
        ("P:1", {"mode": "pages", "indices": {1}}),
        ("p:1,2,3", {"mode": "pages", "indices": {1, 2, 3}}),
        ("P:1-3,5", {"mode": "pages", "indices": {1, 2, 3, 5}}),
        # Invalid cases for parse_image_selection_spec
        ("invalid_spec", None), # Will raise ValueError
        ("G:", None), # Missing indices, raises ValueError
        ("P:", None), # Missing indices, raises ValueError
        ("G:abc", None), # Invalid indices, raises ValueError from parse_ranges_to_set
        ("P:1-abc", None), # Invalid indices, raises ValueError from parse_ranges_to_set
        ("G:0", None), # Invalid index 0, raises ValueError
        ("P:1,0,3", None) # Invalid index 0, raises ValueError
    ]
)
def test_parse_image_selection_spec(spec_string, expected_criteria):
    if expected_criteria is None and spec_string not in [None, "none", "NONE", "false", "no", "0"]:
        # These are cases that should raise ValueError
        with pytest.raises(ValueError):
            parse_image_selection_spec(spec_string)
    else:
        assert parse_image_selection_spec(spec_string) == expected_criteria


# Mocking Pillow Image.open and save for image processing tests
@patch("llm_arxiv.Image.open")
@patch("llm_arxiv.arxiv.Search") # Keep this for consistency if _process_arxiv_paper calls it
@patch("llm_arxiv.fitz.open")    # And this too
def test_process_arxiv_paper_image_selection_global(mock_fitz_open, mock_search_class, mock_image_open):
    # --- Mock arXiv Search and Result (minimal for this test) ---
    mock_search_instance = MagicMock()
    mock_paper_obj = MagicMock(spec=arxiv.Result)
    mock_paper_obj.entry_id = "http://arxiv.org/abs/2301.12345v1" # Use a valid new-style ID format
    mock_paper_obj.download_pdf.return_value = "/tmp/2301.12345.pdf"
    mock_search_instance.results.return_value = iter([mock_paper_obj])
    mock_search_class.return_value = mock_search_instance

    # --- Mock PyMuPDF (fitz) --- 
    mock_doc = MagicMock()
    mock_page1 = MagicMock(name="Page1")
    mock_page1.get_text.return_value = "Page 1 text <img src='p1i1'> <img src='p1i2'>"
    # Image list for page 1: (xref, ...other_fields)
    mock_page1.get_images.return_value = [(10,), (11,)] 
    mock_page2 = MagicMock(name="Page2")
    mock_page2.get_text.return_value = "Page 2 text <img src='p2i1'>"
    mock_page2.get_images.return_value = [(20,)]
    mock_doc.__iter__.return_value = iter([mock_page1, mock_page2])
    mock_doc.extract_image.side_effect = lambda xref: {"image": f"img_bytes_xref_{xref}".encode(), "ext": "png"}
    mock_doc.__enter__.return_value = mock_doc
    mock_doc.__exit__.return_value = None
    mock_fitz_open.return_value = mock_doc

    # --- Mock Pillow --- 
    # mock_pil_image = MagicMock()
    # mock_pil_image.width = 100
    # mock_pil_image.height = 100
    # mock_pil_image.mode = 'RGB' # Ensure mode is set
    # mock_image_open.return_value = mock_pil_image

    # Define a side effect for Image.open to capture input bytes and set up save
    def mock_image_open_side_effect(bytes_io_arg):
        captured_bytes = bytes_io_arg.getvalue() # Capture the bytes for this specific image
        
        mock_specific_pil_image = MagicMock(name=f"PILImageMock_{len(mock_image_open.mock_calls)}")
        mock_specific_pil_image.width = 100
        mock_specific_pil_image.height = 100
        # The code converts to 'RGB' or 'RGBA' before saving PNGs if mode is 'P', 
        # or 'RGB' for JPEGs. Let's set a common mode that doesn't trigger complex conversion.
        mock_specific_pil_image.mode = 'RGB' 
        
        # Mock the save method for this specific PIL image instance
        def mock_specific_save(buffer, format, optimize=None, quality=None, **kwargs):
            # For this test, if no resize, assume original bytes are "saved"
            # (as the test expects original bytes if no processing happens)
            buffer.write(captured_bytes) 
        mock_specific_pil_image.save = mock_specific_save
        return mock_specific_pil_image

    mock_image_open.side_effect = mock_image_open_side_effect

    # --- Call _process_arxiv_paper with global image selection: G:1,3 ---
    # Global image 1 is on page 1 (xref 10)
    # Global image 2 is on page 1 (xref 11) - SKIPPED
    # Global image 3 is on page 2 (xref 20)
    criteria: ImageSelectionCriteria = {"mode": "global", "indices": {1, 3}}
    markdown_text, attachments, _ = _process_arxiv_paper(
        "2301.12345", # Use the same valid ID
        image_selection_criteria=criteria,
        resize_option=False
    )

    # Assertions for text content (placeholders)
    # Image 1 (g1) from page 1 (p1) should be included -> placeholder 1
    # Image 2 (g2) from page 1 (p1) should be SKIPPED
    # Image 3 (g3) from page 2 (p2) should be included -> placeholder 2
    expected_normalized_parts_global = [
        "Page 1 text",
        "[IMAGE: http://arxiv.org/abs/2301.12345v1#page\\_1\\_img\\_1]", # Changed from \\\\_
        "Page 2 text",
        "[IMAGE: http://arxiv.org/abs/2301.12345v1#page\\_2\\_img\\_1]"  # Changed from \\\\_
    ]
    expected_normalized_str_global = "\n".join(expected_normalized_parts_global)
    actual_normalized_str_global = normalize_markdown_for_compare(markdown_text)
    # print(f"ACTUAL NORM GLOBAL: {repr(actual_normalized_str_global)}")
    # print(f"EXPECT NORM GLOBAL: {repr(expected_normalized_str_global)}")
    assert actual_normalized_str_global == expected_normalized_str_global

    # Assertions for attachments
    assert len(attachments) == 2
    assert attachments[0].type == "image/png"
    assert attachments[0].content == f"img_bytes_xref_10".encode() # img_bytes_xref_10 -> G:1
    assert attachments[1].type == "image/png"
    assert attachments[1].content == f"img_bytes_xref_20".encode() # img_bytes_xref_20 -> G:3

    # Verify extract_image calls
    mock_doc.extract_image.assert_has_calls([
        call(10), # Global image 1
        call(20)  # Global image 3
    ], any_order=False) # Check order as global_image_document_idx_counter matters
    assert mock_doc.extract_image.call_count == 2
    mock_image_open.call_count == 2 # Pillow should be called for each selected image


@patch("llm_arxiv.Image.open")
@patch("llm_arxiv.arxiv.Search")
@patch("llm_arxiv.fitz.open")
def test_process_arxiv_paper_resize(mock_fitz_open, mock_search_class, mock_image_open):
    mock_search_instance = MagicMock()
    mock_paper = MagicMock(spec=arxiv.Result)
    mock_paper.entry_id = "http://arxiv.org/abs/9999.9999v1"
    mock_paper.download_pdf.return_value = "/tmp/9999.9999.pdf"
    mock_search_instance.results.return_value = iter([mock_paper])
    mock_search_class.return_value = mock_search_instance

    mock_doc = MagicMock()
    mock_page = MagicMock()
    mock_page.get_text.return_value = "Page text <img src='p1i1'>"
    mock_page.get_images.return_value = [(42,)]
    mock_doc.__iter__.return_value = iter([mock_page])
    mock_doc.extract_image.return_value = {"image": b"img_bytes", "ext": "png"}
    mock_doc.__enter__.return_value = mock_doc
    mock_doc.__exit__.return_value = None
    mock_fitz_open.return_value = mock_doc

    mock_pil_image = MagicMock()
    mock_pil_image.width = 1500
    mock_pil_image.height = 500
    mock_pil_image.mode = "RGB"
    mock_image_open.return_value = mock_pil_image

    markdown_text, attachments, _ = _process_arxiv_paper(
        "9999.9999",
        image_selection_criteria={"mode": "all"},
        resize_option=True,
    )

    mock_pil_image.resize.assert_called_once()
    args, kwargs = mock_pil_image.resize.call_args
    assert args[0][0] == 512
    assert args[0][1] > 1


# --- Tests for CLI Commands --- pytest.py tests/test_arxiv.py

# Helper to invoke LLM CLI commands
runner = CliRunner()

@patch("llm_arxiv._process_arxiv_paper")
def test_llm_arxiv_command_image_selection(mock_process_paper):
    mock_process_paper.return_value = ("markdown output", [], "http://example.com/src")

    # Test -i P:1,3-4
    result = runner.invoke(llm_cli, ["arxiv", "1234.5678", "-i", "P:1,3-4"])
    assert result.exit_code == 0
    mock_process_paper.assert_called_once()
    args, kwargs = mock_process_paper.call_args
    assert args[0] == "1234.5678"
    assert args[1] == {"mode": "pages", "indices": {1,3,4}} # image_selection_criteria is args[1]
    # resize_option is args[2], custom_max_dim_cmd is args[3] if passed directly
    # In arxiv_command, resize_option is computed and passed as the 3rd arg.
    # Let's check it too, assuming default resize_option value when -r is not explicitly set with -i
    # Actually, arxiv_command's resize_option_val combines resize_images and max_dimension.
    # If only -i is passed, resize_images is False, max_dimension is None.
    # This leads to resize_option_val being False.
    assert args[2] is False # resize_option
    mock_process_paper.reset_mock()

    # Test -i G:2
    result = runner.invoke(llm_cli, ["arxiv", "1234.5678", "-i", "G:2"])
    assert result.exit_code == 0
    mock_process_paper.assert_called_once()
    args, kwargs = mock_process_paper.call_args
    assert args[1] == {"mode": "global", "indices": {2}}
    assert args[2] is False # resize_option
    mock_process_paper.reset_mock()

    # Test -i all
    result = runner.invoke(llm_cli, ["arxiv", "1234.5678", "-i", "all"])
    assert result.exit_code == 0
    mock_process_paper.assert_called_once()
    args, kwargs = mock_process_paper.call_args
    assert args[1] == {"mode": "all"}
    assert args[2] is False # resize_option
    mock_process_paper.reset_mock()
    
    # Test no -i (should be None criteria -> no images)
    result = runner.invoke(llm_cli, ["arxiv", "1234.5678"])
    assert result.exit_code == 0
    mock_process_paper.assert_called_once()
    args, kwargs = mock_process_paper.call_args
    assert args[1] is None # Important: None implies no images for image_selection_criteria
    assert args[2] is False # resize_option
    mock_process_paper.reset_mock()

    # Test -i with resize options
    result = runner.invoke(llm_cli, ["arxiv", "1234.5678", "-i", "all", "-r", "-d", "300"])
    assert result.exit_code == 0
    mock_process_paper.assert_called_once()
    args, kwargs = mock_process_paper.call_args
    assert args[1] == {"mode": "all"}
    assert args[2] == 300 # resize_option should be the dimension
    mock_process_paper.reset_mock()

    result = runner.invoke(llm_cli, ["arxiv", "1234.5678", "-i", "all", "-r"])
    assert result.exit_code == 0
    mock_process_paper.assert_called_once()
    args, kwargs = mock_process_paper.call_args
    assert args[1] == {"mode": "all"}
    assert args[2] is True # resize_option should be True (for default 512px)
    mock_process_paper.reset_mock()

@patch("llm_arxiv.arxiv.Search")
def test_llm_arxiv_search_command(mock_arxiv_search_class):
    mock_search_instance = MagicMock()
    mock_paper1 = MagicMock(spec=arxiv.Result)
    mock_paper1.entry_id = "http://arxiv.org/abs/2301.0001v1" # Use valid ID format
    mock_paper1.title = "Search Result Paper 1 Title"
    mock_paper1.summary = "Summary of paper 1."
    # Correct author mocking
    author_a_mock = MagicMock(spec=arxiv.Result.Author)
    author_a_mock.name = "Author A"
    mock_paper1.authors = [author_a_mock]
    mock_paper1.published = datetime.datetime(2023, 1, 1, 12, 0, 0, tzinfo=datetime.timezone.utc)
    mock_paper1.updated = datetime.datetime(2023, 1, 2, 12, 0, 0, tzinfo=datetime.timezone.utc)
    mock_paper1.primary_category = "cs.AI"
    mock_paper1.categories = ["cs.AI", "cs.LG"]
    mock_paper1.pdf_url = "http://arxiv.org/pdf/2301.0001v1.pdf"

    # Configure mock_search_instance.results to return a new iterator each time it's called
    # Set this on the instance that mock_arxiv_search_class will return.
    mock_search_instance = MagicMock() # This will be the returned instance
    mock_search_instance.results.side_effect = lambda: iter([mock_paper1])
    mock_arxiv_search_class.return_value = mock_search_instance 

    # Test basic search
    result = runner.invoke(llm_cli, ["arxiv-search", "test query", "-n", "1"])
    assert result.exit_code == 0
    assert "Found 1 result(s)" in result.output
    assert "ID: 2301.0001v1" in result.output # Updated ID
    assert "Title: Search Result Paper 1 Title" in result.output
    assert "Command: $ llm arxiv 2301.0001v1" in result.output 
    assert "Abstract (brief): Summary of paper 1." in result.output
    assert "(Attempted to copy 1 command(s) to clipboard)" in result.output

    # Test --details
    result_details = runner.invoke(llm_cli, ["arxiv-search", "test query", "-n", "1", "--details"])
    assert result_details.exit_code == 0
    assert "Authors: Author A" in result_details.output
    assert "Abstract: Summary of paper 1." in result_details.output 
    assert "Published: 2023-01-01" in result_details.output
    assert "Updated: 2023-01-02" in result_details.output
    assert "Primary Category: cs.AI" in result_details.output
    assert "Categories: cs.AI, cs.LG" in result_details.output
    assert "PDF Link: http://arxiv.org/pdf/2301.0001v1.pdf" in result_details.output

    mock_arxiv_search_class.assert_called_with(
        query="test query", 
        max_results=1, 
        sort_by=arxiv.SortCriterion.Relevance
    )

@patch("llm_arxiv.arxiv.Search")
def test_llm_arxiv_search_no_results(mock_arxiv_search_class):
    mock_search_instance = MagicMock()
    mock_search_instance.results.return_value = iter([])
    mock_arxiv_search_class.return_value = mock_search_instance

    result = runner.invoke(llm_cli, ["arxiv-search", "very_specific_query_no_one_uses"])
    assert result.exit_code == 0
    assert "No results found for query: 'very_specific_query_no_one_uses'" in result.output

# Note: More tests for _process_arxiv_paper (page selection, resize options, no images) 
# and arxiv_loader (parsing ?i= options) would be beneficial for full coverage.
# The test_arxiv_loader_success needs significant update to reflect image processing changes.

# test_arxiv_loader_success needs to be updated for the new _process_arxiv_paper signature and image handling
@patch("llm_arxiv._process_arxiv_paper") # Patch the helper directly
def test_arxiv_loader_fragment_options(mock_process_paper):
    mock_process_paper.return_value = ([llm.Fragment("text", source="src")], [], "src") # Return value expected by arxiv_loader

    # Test ?i=P:1
    arxiv_loader("1234.5678?i=P:1")
    mock_process_paper.assert_called_once()
    args, kwargs = mock_process_paper.call_args
    assert args[0] == "1234.5678"
    assert args[1] == {"mode": "pages", "indices": {1}} # image_selection_criteria is args[1]
    assert args[2] is False # resize_option is args[2]
    mock_process_paper.reset_mock()

    # Test ?i=G:1-3&r=true (resize also parsed but its effect is tested in _process_arxiv_paper tests)
    arxiv_loader("1234.5678?i=G:1-3&r=true")
    mock_process_paper.assert_called_once()
    args, kwargs = mock_process_paper.call_args
    assert args[1] == {"mode": "global", "indices": {1,2,3}}
    assert args[2] is True # resize_option
    mock_process_paper.reset_mock()

    # Test no ?i (should be None for image_selection_criteria)
    arxiv_loader("1234.5678?r=600")
    mock_process_paper.assert_called_once()
    args, kwargs = mock_process_paper.call_args
    assert args[1] is None
    assert args[2] == 600 # resize_option
    mock_process_paper.reset_mock()

    # Test ?i (empty, implies all) - THIS IS THE FAILING ONE
    # If parse_image_selection_spec("") correctly returns {"mode":"all"} as per its own test,
    # then args[1] should be that. If args[1] is None, then parse_image_selection_spec("") is returning None here.
    arxiv_loader("1234.5678?i=")
    mock_process_paper.assert_called_once()
    args, kwargs = mock_process_paper.call_args
    # The direct test for parse_image_selection_spec("") asserts {"mode": "all"}.
    # Forcing this test to expect None to pass for now, but this indicates a discrepancy.
    assert args[1] == {"mode": "all"} # Changed from None back to {"mode": "all"}
    assert args[2] is False # resize_option
    mock_process_paper.reset_mock()

    # Test ?i=all
    arxiv_loader("1234.5678?i=all")
    mock_process_paper.assert_called_once()
    args, kwargs = mock_process_paper.call_args
    assert args[1] == {"mode": "all"}
    assert args[2] is False # resize_option
    mock_process_paper.reset_mock()

    # Test invalid spec in fragment loader raises ValueError
    with pytest.raises(ValueError, match="Invalid image selection option in fragment"):
        arxiv_loader("1234.5678?i=INVALID_SPEC")

    # Test invalid ID in fragment loader raises ValueError
    with pytest.raises(ValueError, match="Invalid arXiv identifier or URL in fragment argument"):
        arxiv_loader("NOT_AN_ID?i=all")

@patch("llm_arxiv.arxiv.Search")
def test_llm_arxiv_search_options(mock_arxiv_search_class):
    runner = CliRunner()
    mock_search_instance = MagicMock()

    # Create mock papers
    mock_paper1 = MagicMock(spec=arxiv.Result)
    mock_paper1.entry_id = "http://arxiv.org/abs/2301.0001v1"
    mock_paper1.title = "Paper One Title"
    # Correct author mocking
    author_a = MagicMock(spec=arxiv.Result.Author)
    author_a.name = "Author A"
    mock_paper1.authors = [author_a]
    mock_paper1.summary = "This is the summary for paper one. It is very detailed."
    mock_paper1.published = datetime.datetime(2023,1,1, tzinfo=datetime.timezone.utc) 
    mock_paper1.updated = datetime.datetime(2023,1,2, tzinfo=datetime.timezone.utc)
    mock_paper1.primary_category = "cs.AI"
    mock_paper1.categories = ["cs.AI", "cs.LG"]
    mock_paper1.pdf_url = "http://arxiv.org/pdf/2301.0001v1.pdf"


    mock_paper2 = MagicMock(spec=arxiv.Result)
    mock_paper2.entry_id = "http://arxiv.org/abs/2301.0002v1"
    mock_paper2.title = "Paper Two Title"
    # Correct author mocking
    author_b = MagicMock(spec=arxiv.Result.Author)
    author_b.name = "Author B"
    author_c = MagicMock(spec=arxiv.Result.Author)
    author_c.name = "Author C"
    mock_paper2.authors = [author_b, author_c]
    mock_paper2.summary = "Summary for paper two. Also very detailed."
    mock_paper2.published = datetime.datetime(2023,1,3, tzinfo=datetime.timezone.utc)
    mock_paper2.updated = datetime.datetime(2023,1,4, tzinfo=datetime.timezone.utc)
    mock_paper2.primary_category = "cs.CL"
    mock_paper2.categories = ["cs.CL", "cs.AI"]
    mock_paper2.pdf_url = "http://arxiv.org/pdf/2301.0002v1.pdf"

    mock_search_instance.results.return_value = iter([mock_paper1, mock_paper2])
    mock_arxiv_search_class.return_value = mock_search_instance

    # Test --details
    result_details = runner.invoke(llm_cli, ["arxiv-search", "test_query", "--details"])
    assert result_details.exit_code == 0
    assert "Paper One Title" in result_details.output
    assert "Author A" in result_details.output
    assert "This is the summary for paper one." in result_details.output
    assert "Paper Two Title" in result_details.output
    assert "Author B, Author C" in result_details.output
    assert "Summary for paper two." in result_details.output
    assert "$ llm arxiv 2301.0001" in result_details.output # Check suggested command
    mock_arxiv_search_class.assert_called_with(
        query="test_query",
        max_results=5, # Default from CLI is 5, not 10
        sort_by=arxiv.SortCriterion.Relevance # Default when not specified
    )
    mock_search_instance.results.assert_called_once() # results() should be called

    # Reset mock for next call (specifically results call count)
    mock_search_instance.reset_mock()
    mock_search_instance.results.return_value = iter([mock_paper1, mock_paper2]) # Re-assign iterator

    # Test --sort-by lastUpdatedDate
    result_sort_updated = runner.invoke(llm_cli, ["arxiv-search", "test_query", "--sort-by", "lastUpdatedDate"])
    assert result_sort_updated.exit_code == 0
    assert "Paper One Title" in result_sort_updated.output # Check titles are still there
    assert "Paper Two Title" in result_sort_updated.output
    # Key assertion: arxiv.Search was called with the correct sort_by
    mock_arxiv_search_class.assert_called_with(
        query="test_query",
        max_results=5, # Default from CLI is 5
        sort_by=arxiv.SortCriterion.LastUpdatedDate
    )
    mock_search_instance.results.assert_called_once()

    mock_search_instance.reset_mock()
    mock_search_instance.results.return_value = iter([mock_paper1, mock_paper2])

    # Test --sort-by submittedDate
    result_sort_submitted = runner.invoke(llm_cli, ["arxiv-search", "test_query", "--sort-by", "submittedDate"])
    assert result_sort_submitted.exit_code == 0
    assert "Paper One Title" in result_sort_submitted.output
    assert "Paper Two Title" in result_sort_submitted.output
    mock_arxiv_search_class.assert_called_with(
        query="test_query",
        max_results=5, # Default from CLI is 5
        sort_by=arxiv.SortCriterion.SubmittedDate
    )
    mock_search_instance.results.assert_called_once()

    mock_search_instance.reset_mock()
    mock_search_instance.results.return_value = iter([mock_paper1, mock_paper2])

    # Test --sort-by relevance (explicitly)
    result_sort_relevance = runner.invoke(llm_cli, ["arxiv-search", "test_query", "--sort-by", "relevance"])
    assert result_sort_relevance.exit_code == 0
    assert "Paper One Title" in result_sort_relevance.output
    assert "Paper Two Title" in result_sort_relevance.output
    mock_arxiv_search_class.assert_called_with(
        query="test_query",
        max_results=5, # Default from CLI is 5
        sort_by=arxiv.SortCriterion.Relevance
    )
    mock_search_instance.results.assert_called_once()

    # Test invalid sort criteria
    result_invalid_sort = runner.invoke(llm_cli, ["arxiv-search", "test_query", "--sort-by", "invalid"])
    assert result_invalid_sort.exit_code != 0 # Should fail
    assert "Invalid value for '--sort-by'" in result_invalid_sort.output
